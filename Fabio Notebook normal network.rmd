---
title: "Munich less dense"
output:
  html_document:
    df_print: paged
---

## Packages and Functions

```{r}
# Data manipulation
library(tidyverse)
library(data.table) 

# Spatial operations
library(sf)
library(raster)
library(furrr)
library(stars)

# Matrix operations
library(Matrix)

# MNO data handling and propagation model setup
library(mobloc)

# Comparison of 2d histograms (Kantorovitch Wasserstein distance a.k.a. Earth Movers distance)
library(SpatialKWD)

# Output organisation and plotting support
library(ggthemes)
library(viridis)
library(ggrepel)
library(ggpointdensity)
library(grid)
library(gridExtra)
library(knitr)
library(DT)

# seed for reproducibility
set.seed(42)


# Loading Custom functions
source("Code/pipeline functions.R")

```

## Load Munich data

```{r}
# munich
munich.raw <- readRDS("Data/munich.rds")

munich.raster <- rasterFromXYZ(munich.raw, crs = st_crs(3035)$proj4string)
munich <- NULL

munich$area.sf <- munich.raster %>%
  st_as_stars() %>%
  st_as_sf() %>%
  dplyr::select(tile.id, pop, elevation) %>%
  mutate(type = "NA")

munich$area.df <- munich$area.sf %>%
  st_drop_geometry()

munich$area.union <- munich$area.sf %>%
  st_union()

munich$area.bbox <- munich$area.union %>%
  st_bbox(crs = sf::st_crs(3035))

munich$area.raster <- munich.raster %>%
  raster(., layer = "tile.id")

munich$area.elevation <- munich.raster %>%
  raster(., layer = "elevation")

munich$area.params[["tile.num"]] <- length(munich$area.df$tile.id)
munich$area.params[["base.tile.size"]] <- as.numeric(sqrt(st_area(munich$area.sf[1,])))

## renaming
area <- munich


# summary plots
breaks <- c(0, 2, 10, 20, 50, 100, 200, 500, 1000, Inf)
area$area.sf %>% 
  mutate(pop.cat = cut(pop, breaks = breaks, dig.lab = 7, right = F)) %>% 
  map_density(data = ., var = "pop.cat", label = "GTP")

pop_summary_results(area$area.sf)

density_plots(area$area.df)


```



## Create radio network (less dense)

```{r, fig.height=8, fig.width=10}
# specify parameters of each cell
MA.cell.param.mobloc <- mobloc_param(W = 5, range = 10000, ple = 3.4, height = 10,
                                     midpoint = -85, steepness = 0.15, sig_d_th = 0.05)

ME.cell.param.mobloc <- mobloc_param(W = 50, range = 3500, ple = 3.8, height = 10,
                                     midpoint = -85, steepness = 0.3, sig_d_th = 0.05)

MI.cell.param.mobloc <- mobloc_param(W = 1, range = 3500, ple = 4, height = 6,
                                     midpoint = -85, steepness = 0.4, sig_d_th = 0.05)

# create dataframe for theoretical signal strength distribution
param.df <- tibble(cell.kind = c("MA", "ME", "MI"),
                   label = c("Macro", "Meso", "Micro"),
                   W = c(MA.cell.param.mobloc$W, ME.cell.param.mobloc$W, MI.cell.param.mobloc$W),
                   ple = c(MA.cell.param.mobloc$ple, ME.cell.param.mobloc$ple, MI.cell.param.mobloc$ple),
                   range = c(MA.cell.param.mobloc$range, ME.cell.param.mobloc$range, MI.cell.param.mobloc$range),
                   midpoint = c(MA.cell.param.mobloc$midpoint, ME.cell.param.mobloc$midpoint, MI.cell.param.mobloc$midpoint),
                   steepness = c(MA.cell.param.mobloc$steepness, ME.cell.param.mobloc$steepness, MI.cell.param.mobloc$steepness),
                   dominance.th = c(MA.cell.param.mobloc$sig_d_th,
                                    ME.cell.param.mobloc$sig_d_th,
                                    MI.cell.param.mobloc$sig_d_th))

param.df.reduced <- param.df %>% 
  dplyr::select(cell.kind, dominance.th)

# visualize theoretical signal parameter plots
sig.pram.plots <- sig_param_plots(param.df = param.df, range.max = 20000, base_size = 11)
a <- ggpubr::as_ggplot(sig.pram.plots$final)
ggsave("Network kind/Less dense/Plots/coverage.diag.png", a, device = "png", width = 10)

set.seed(100)

# create tower positions with attached cells
MA.cells.unparam <- create_cells(area.sf = area$area.sf, 
                                 tower.dist = 8500, rotation.deg = 0, 
                                 jitter = 1000, small = FALSE, 
                                 subscript = "MA", seed = 3)

ME.cells.unparam <- create_cells(area.sf = area$area.sf,
                                 tower.dist = 4200, rotation.deg = 35,
                                 jitter = 700, small = FALSE,
                                 subscript = "ME", seed = 7)

MI.cells.unparam <- create_cells(area.sf = area$area.sf,
                                 tower.dist = 10000, rotation.deg = 60,
                                 jitter = 2000, small = FALSE,
                                 subscript = "MI", seed = 10)


# create the cellplan and validate it with the specified parameters
MA.cellplan.val <- create_cellplan(area.sf = area$area.sf,  
                                   area.bbox = area$area.bbox, 
                                   area.elevation = area$area.elevation,
                                   cells.unparam = MA.cells.unparam,
                                   cell.param.mobloc = MA.cell.param.mobloc)

ME.cellplan.val <- create_cellplan(area.sf = area$area.sf,
                                   area.bbox = area$area.bbox,
                                   area.elevation = area$area.elevation,
                                   cells.unparam = ME.cells.unparam,
                                   cell.param.mobloc = ME.cell.param.mobloc)

MI.cellplan.val <- create_cellplan(area.sf = area$area.sf,
                                   area.bbox = area$area.bbox,
                                   area.elevation = area$area.elevation,
                                   cells.unparam = MI.cells.unparam,
                                   cell.param.mobloc = MI.cell.param.mobloc)
# cellplans need to be made valid!

cellplan.combined <- bind_rows(as_tibble(MA.cellplan.val$cellplan.val),
                               as_tibble(ME.cellplan.val$cellplan.val),
                               as_tibble(MI.cellplan.val$cellplan.val)) %>% 
  mutate(cell.kind = substr(cell, 1, 2)) %>% 
  left_join(param.df.reduced, by = "cell.kind") # join dominance threshold to use later in create_strength_llh()

# to join variable dominance.th later on
cellplan.combined.reduced <- cellplan.combined %>% 
  dplyr::select(cell, dominance.th)


# compute signal strength and device to cell association
MA.signal.strength <- compute_sig_strength(cp = MA.cellplan.val$cellplan.val, 
                                           raster = area$area.raster, 
                                           param = MA.cellplan.val$cell.param.mobloc, 
                                           elevation = area$area.elevation)

ME.signal.strength <- compute_sig_strength(cp = ME.cellplan.val$cellplan.val,
                                           raster = area$area.raster,
                                           param = ME.cellplan.val$cell.param.mobloc,
                                           elevation = area$area.elevation)

MI.signal.strength <- compute_sig_strength(cp = MI.cellplan.val$cellplan.val,
                                           raster = area$area.raster,
                                           param = MI.cellplan.val$cell.param.mobloc,
                                           elevation = area$area.elevation)

# create signal strength object of all cells
signal.strength.comb.dt <- rbindlist(list(MA.signal.strength,
                                          ME.signal.strength,
                                          MI.signal.strength))

  


signal.strength.summary.helper <- signal.strength.comb.dt %>%
  as_tibble() %>%
  mutate(tile.id = as.character(rid)) %>%
  mutate(cell.kind = substr(cell, 1, 2)) %>%
  mutate(cell.chr = as.character(cell)) %>%
  left_join(cellplan.combined.reduced, by = c("cell.chr" = "cell")) %>% 
  filter(!s < dominance.th) # filter rows out that are below the set dominance threshold

signal.strength.summary <- signal.strength.summary.helper %>% 
  group_by(tile.id) %>%
  mutate(max.dBm = max(dBm),
         max.s = max(s),
         min.dist = min(dist)) %>%
  ungroup()


# identify the cell-tile relations with maximum signal dominance and identify tiles that are not covered sufficiently
signal.dom <- signal.strength.summary %>% 
  distinct(tile.id, max.s) %>%
  left_join(signal.strength.summary, by = c("tile.id", "max.s" = "s")) %>% 
  dplyr::select(tile.id, max.s, cell, cell.kind) %>% 
  mutate(tile.id = as.integer(tile.id)) %>% 
  full_join(area$area.sf, by = "tile.id") %>% 
  mutate(missing = case_when(is.na(max.s) ~ 1,
                             TRUE ~ 0))

# how many tiles are not sufficiently covered
paste0("Number of tiles which do not reach the signal dominance threshold of: " , sum(signal.dom$missing))
# paste0("Number of tiles which do not reach the signal dominance threshold of ", sig_d_th, ": " , sum(signal.dom$missing))
```


### develop finer grid for contour plots
This chunk is just computed for the contour plots to be smoother
```{r}
finer.grid.factor <- 2
finer.grid.tile.id <- c(1:640000) # adjust to grid factor

area$area.raster.finer <- disaggregate(area$area.raster, finer.grid.factor) %>% 
  setValues(., finer.grid.tile.id)

area$area.elevation.finer <- disaggregate(area$area.elevation, finer.grid.factor)

area$area.finer.grid.sf <- st_as_sf(st_as_stars(area$area.raster.finer))

# compute signal strength and device to cell association
MA.signal.strength.finer <- compute_sig_strength(cp = MA.cellplan.val$cellplan.val, 
                                                 raster = area$area.raster.finer, 
                                                 param = MA.cellplan.val$cell.param.mobloc, 
                                                 elevation = area$area.elevation.finer)

ME.signal.strength.finer <- compute_sig_strength(cp = ME.cellplan.val$cellplan.val,
                                                 raster = area$area.raster.finer,
                                                 param = ME.cellplan.val$cell.param.mobloc,
                                                 elevation = area$area.elevation.finer)

MI.signal.strength.finer <- compute_sig_strength(cp = MI.cellplan.val$cellplan.val,
                                                 raster = area$area.raster.finer,
                                                 param = MI.cellplan.val$cell.param.mobloc,
                                                 elevation = area$area.elevation.finer)

signal.strength.comb.dt.finer.grid <- rbindlist(list(MA.signal.strength.finer,
                                                     ME.signal.strength.finer,
                                                     MI.signal.strength.finer))


area.reduced.contour <- area$area.finer.grid.sf %>% 
  dplyr::select(tile.id.num = tile.id) %>% 
  mutate(lon = map_dbl(geometry, ~st_centroid(.x)[[1]]),
         lat = map_dbl(geometry, ~st_centroid(.x)[[2]]))

crs.set <- st_crs(area.reduced.contour)

contour.data.raw <- signal.strength.comb.dt.finer.grid %>%
  as_tibble() %>%
  mutate(tile.id.num = as.numeric(rid)) %>%
  mutate(cell.chr = as.character(cell)) %>%
  left_join(cellplan.combined, by = c("cell.chr" = "cell")) %>% 
  filter(!s < dominance.th) %>% 
  mutate(s.discrete = case_when(s <= 0.5 ~ 1,
                                s > 0.5 ~ 2)) %>% # define categoristation of contours
  dplyr::select(cell, cell.kind, x.tow = x, y.tow = y, direction, tile.id.num, s, s.discrete) %>% 
  left_join(area.reduced.contour, by = c("tile.id.num")) %>% 
  st_as_sf(coords = c("lon", "lat"), crs = crs.set) 

contour.data.raw.split <- contour.data.raw %>% 
  st_drop_geometry() %>% 
  split(.$cell.kind) %>% 
  map(~distinct(., cell, x.tow, y.tow))

contour.data.summary <- contour.data.raw %>% 
  dplyr::select(cell, cell.kind, s.discrete, s) %>% 
  dplyr::group_by(cell, cell.kind, s.discrete) %>%
  dplyr::summarise() %>%
  st_convex_hull()

(contour.complete.MA <- contour.data.summary %>% 
  filter(cell.kind == "MA" & s.discrete == "1") %>% 
  ggplot() +
  geom_sf(data = area$area.union) +
  geom_sf(color = "red", fill = "transparent") +
  geom_point(data = contour.data.raw.split$MA, aes(x = x.tow, y = y.tow), color = "black", shape = 2) +
  theme_minimal() +
  labs(x = "", y = ""))
ggsave("Network kind/Less dense/Plots/contour.complete.MA.finer.png", contour.complete.MA, device = "png")

(contour.complete.ME <- contour.data.summary %>% 
  filter(cell.kind == "ME" & s.discrete == "1") %>% 
  ggplot() +
  geom_sf(data = area$area.union) +
  geom_sf(color = "red", fill = "transparent") +
  geom_point(data = contour.data.raw.split$ME, aes(x = x.tow, y = y.tow), color = "blue", shape = 2) +
  theme_minimal() +
  labs(x = "", y = ""))
ggsave("Network kind/Less dense/Plots/contour.complete.ME.finer.png", contour.complete.ME, device = "png")

(contour.complete.MI <- contour.data.summary %>% 
  filter(cell.kind == "MI" & s.discrete == "1") %>% 
  ggplot() +
  geom_sf(data = area$area.union) +
  geom_sf(color = "red", fill = "transparent") +
  geom_point(data = contour.data.raw.split$MI, aes(x = x.tow, y = y.tow), color = "green", shape = 2) +
  theme_minimal() +
  labs(x = "", y = ""))
ggsave("Network kind/Less dense/Plots/contour.complete.MI.finer.png", contour.complete.MI, device = "png")


(contour.certain <- contour.data.summary %>% 
  filter(str_detect(cell, "MA.12.|ME.100.|MI.18.")) %>% 
  ggplot() +
  geom_sf(data = area$area.union) +
  geom_sf(aes(color = factor(s.discrete)), fill = "transparent") +
  geom_point(data = contour.data.raw.split$MA, aes(x = x.tow, y = y.tow), color = "black", shape = 2) +
  geom_point(data = contour.data.raw.split$ME, aes(x = x.tow, y = y.tow), color = "blue", shape = 2) +
  geom_point(data = contour.data.raw.split$MI, aes(x = x.tow, y = y.tow), color = "green", shape = 2) +
  scale_color_discrete("Signal dom.", breaks = c("1", "2"), labels = c("0.05 <= s < 0.5",
                                                                      "s >= 0.5")) +
  theme_minimal() +
  labs(x = "", y = ""))
ggsave("Network kind/Less dense/Plots/hull.certain.finer.png", contour.certain, device = "png")
```

### These coverage diagnostics plot still need to be refined

```{r}
# maximum of two rows per tile, tiles with only one row, mean they are only covered by one cell.kind
signal.strength.summary.ck <- signal.strength.summary.helper %>% 
  group_by(tile.id, cell.kind) %>%
  summarise(cell.count = n(),
            max.dBm = max(dBm),
            max.s = max(s),
            min.dist = min(dist)) %>% 
  mutate(cell.count.complete = sum(cell.count),
         max.dBm.complete = max(max.dBm),
         max.s.complete = max(max.s), 
         min.dist.complete = max(min.dist)) %>% 
  ungroup() %>% 
  pivot_longer(cols = -c(tile.id, cell.kind),
               names_to = "kind", 
               values_to = "values") # possibly different pivot to get "kind" into multiple variables


# histogram cells
tile.coverage.hist <- signal.strength.summary.ck %>%
  filter(str_detect(kind, pattern = "count")) %>% 
  mutate(cat = case_when(str_detect(kind, pattern = "complete") ~ "complete",
                         TRUE ~ paste0(cell.kind))) %>% 
  distinct(tile.id, cat, .keep_all = T) %>% 
  dplyr::select(-cell.kind) %>% 
  ggplot() +
  geom_histogram(aes(values), binwidth = 1) +
  # scale_x_continuous(breaks = seq(0, 12, 1)) + # respecify to be dynamic
  facet_grid(~cat) +
  labs(title = "Number of cells a tile is covered by",
       y = "Tile count",
       x = "Number of cells")


# build graph with rotating triangle
coverage.map.dom.df.MA <- signal.strength.summary.ck %>%
  filter(str_detect(kind, pattern = "max.s")) %>% 
  mutate(cat = case_when(str_detect(kind, pattern = "complete") ~ "complete",
                         TRUE ~ paste0(cell.kind))) %>% 
  filter(cat == "MA") %>% 
  dplyr::select(-cell.kind) %>% 
  mutate(tile.id.num = as.numeric(tile.id)) %>% 
  full_join(area$area.sf, by = c("tile.id.num" = "tile.id")) %>%  # change later on
  mutate(missing = case_when(is.na(values) ~ 1,
                             TRUE ~ 0)) %>% 
  st_as_sf()

coverage.map.dom.df.ME <- signal.strength.summary.ck %>%
  filter(str_detect(kind, pattern = "max.s")) %>% 
  mutate(cat = case_when(str_detect(kind, pattern = "complete") ~ "complete",
                         TRUE ~ paste0(cell.kind))) %>% 
  filter(cat == "ME") %>% 
  dplyr::select(-cell.kind) %>% 
  mutate(tile.id.num = as.numeric(tile.id)) %>% 
  full_join(area$area.sf, by = c("tile.id.num" = "tile.id")) %>%  # change later on
  mutate(missing = case_when(is.na(values) ~ 1,
                             TRUE ~ 0)) %>% 
  st_as_sf()

coverage.map.dom.df.complete <- signal.strength.summary.ck %>%
  filter(str_detect(kind, pattern = "max.s")) %>% 
  mutate(cat = case_when(str_detect(kind, pattern = "complete") ~ "complete",
                         TRUE ~ paste0(cell.kind))) %>% 
  filter(cat == "complete") %>% 
  distinct(tile.id, cat, .keep_all = T) %>% 
  dplyr::select(-cell.kind) %>% 
  mutate(tile.id.num = as.numeric(tile.id)) %>% 
  full_join(area$area.sf, by = c("tile.id.num" = "tile.id")) %>%  # change later on
  mutate(missing = case_when(is.na(values) ~ 1,
                             TRUE ~ 0)) %>% 
  st_as_sf()

coverage.map.MA <- coverage.map.dom.df.MA %>% 
  ggplot() +
  geom_sf(aes(fill = values), color = "transparent") +
  geom_point(data = as_tibble(MA.cellplan.val$cellplan.val), aes(x, y),
             shape = 2, color = "#F8766D") +
  scale_fill_gradient(low = "white", high = "black", na.value = "red", 
                      limits = c(0, 1)) +
  labs(title = "MA Coverage", 
       fill = "Signal Dominance",
       x = "",
       y = "") +
  theme(plot.margin = unit(c(0, 0, 0, 0), "cm"),
        axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank(),
        legend.position = "none")

coverage.map.ME <- coverage.map.dom.df.ME %>% 
  ggplot() +
  geom_sf(aes(fill = values), color = "transparent") +
  geom_point(data = as_tibble(ME.cellplan.val$cellplan.val), aes(x, y),
             shape = 2, color = "#00BFC4") +
  scale_fill_gradient(low = "white", high = "black", na.value = "red", 
                      limits = c(0, 1)) +
  labs(title = " ME Coverage", 
       fill = "Signal Dominance",
       x = "",
       y = "") +
  theme(plot.margin = unit(c(0, 0, 0, 0), "cm"),
        legend.position = "none",
        axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank())

coverage.map.complete <- coverage.map.dom.df.complete %>% 
  ggplot() +
  geom_sf(aes(fill = values), color = "transparent") +
  geom_point(data = cellplan.combined, aes(x, y, color = cell.kind),
             shape = 2) +
  scale_fill_gradient(low = "white", high = "black", na.value = "red", 
                      limits = c(0, 1)) +
  labs(title = "Complete coverage", 
       color = "Tower kind",
       fill = "Signal Dominance",
       x = "",
       y = "") +
  theme(axis.title.x = element_blank(),
        axis.text.x = element_blank(),
        axis.ticks.x = element_blank(),
        axis.title.y = element_blank(),
        axis.text.y = element_blank(),
        axis.ticks.y = element_blank())

# coverage.map.dom.df.binary <- signal.strength.summary.ck %>%
#   filter(str_detect(kind, pattern = "max.s"),
#          !str_detect(kind, pattern = "complete")) %>%
#   group_by(tile.id) %>%
#   # mutate(values = round(values, 2)) %>% 
#   filter(values == max(values)) %>%
#   ungroup() %>%
#   mutate(tile.id.num = as.numeric(tile.id)) %>%
#   full_join(area$area.sf, by = c("tile.id.num" = "tile.id")) %>%  # change later on
#   mutate(missing = case_when(is.na(values) ~ 1,
#                              TRUE ~ 0)) %>%
#   st_as_sf()
# 
# 
# coverage.map.binary <- coverage.map.dom.df.binary %>%
#   sample_n(2000) %>% 
#   ggplot() +
#   geom_sf(aes(fill = cell.kind), color = "transparent", alpha = 0.3, show = FALSE) +
#   geom_point(data = cellplan.combined, aes(x, y, color = cell.kind),
#              shape = 2) +
#   labs(title = "Binary coverage",
#        color = "Tower kind",
#        x = "",
#        y = "") +
#   theme(axis.title.x = element_blank(),
#         axis.text.x = element_blank(),
#         axis.ticks.x = element_blank(),
#         axis.title.y = element_blank(),
#         axis.text.y = element_blank(),
#         axis.ticks.y = element_blank())

coverage.diag <- arrangeGrob(coverage.map.MA, coverage.map.ME, 
                             coverage.map.complete, tile.coverage.hist, 
                             layout_matrix = rbind(c(1, 2),
                                                   c(3, 4)))
# coverage.map.MA
# coverage.map.ME
# coverage.map.complete
# tile.coverage.hist



```


## Device to cell association (creation of c.vector)

```{r}
# specify the option of differing parameters for sig_d_th and max_overlapping_cells depending on the cell type in custom create_strength_llh function

# Workaround: securing that sig_d_th and max_overlapping_cells are the same
signal.strength.llh.param <- list(sig_d_th = max(cellplan.combined.reduced$dominance.th),
                                  max_overlapping_cells = 100)


# creating the long format of the P matrix
# MA.signal.strength.llh <- create_strength_llh(strength = MA.signal.strength, 
#                                               param = signal.strength.llh.param)
# 
# ME.signal.strength.llh <- create_strength_llh(strength = ME.signal.strength, 
#                                               param = signal.strength.llh.param)

signal.strength.llh.combined <- create_strength_llh(strength = signal.strength.comb.dt, 
                                                    param = signal.strength.llh.param) %>% 
  as_tibble() %>% 
  mutate(tile.id = rid) %>% 
  group_by(tile.id) %>%
  mutate(pij = smart.round(pag, 3)) %>%
  ungroup() %>%
  left_join(area$area.df, by = "tile.id") %>% 
  mutate(coverage.kind = case_when(pop == 0 ~ "0 population",
                                   pij == 1 ~ "covered completely by one antenna",
                                   pij > 0 & pij < 1 ~ "covered by multiple antennas",
                                   pij == 0 ~ "tile covered unsufficiently")) %>% 
  dplyr::select(-pag)

# aggregating and specifying the tiles that are uncovered (if there are some)
tiles.cat <- signal.strength.llh.combined %>% 
  filter(!pij == 0) %>% 
  dplyr::select(tile.id, coverage.kind) %>% 
  group_by(tile.id) %>% 
  summarise(count = n())

# how many tiles are not sufficiently covered
missings <- anti_join(area$area.df, tiles.cat, by = "tile.id") # implement non zero pop
paste("Number of tiles which are unsufficiently covered:", length(missings$tile.id))

# covered only by one tile
C.vec.fixed.helper <- signal.strength.llh.combined %>% 
  filter(coverage.kind == "covered completely by one antenna") %>%
  dplyr::select(tile.id, cell, pop)

# One object where tiles are covered by multiple cells
C.vec.multiple.helper <- signal.strength.llh.combined %>% 
  filter(coverage.kind == "covered by multiple antennas") %>% 
  group_split(tile.id) 

# Calculate the number of cores
no_cores <- availableCores() - 1
plan(multisession, workers = no_cores)

C.vec.multiple <- C.vec.multiple.helper %>% 
  future_map(~sample(x = .$cell, mean(.$pop),
                     replace = T, prob = .$pij), 
             .options = furrr_options(seed = T), .progress = T) %>% 
  future_map(as_tibble, .id = "tile.id", .progress = T) %>% 
  future_map(~group_by(., value), .progress = T) %>% 
  future_map(~summarise(., pop.count.rand = n(), .groups = "drop"), 
             .progress = T)

C.vec.df <- C.vec.multiple %>% 
  bind_rows() %>% 
  dplyr::select(cell = value, pop = pop.count.rand) %>% 
  bind_rows(C.vec.fixed.helper) %>% 
  group_by(cell) %>% 
  summarise(phones.sum = sum(pop))

(c.vec.hist <- C.vec.df %>% 
  ggplot() +
  geom_histogram(aes(phones.sum)) +
  labs(title = "Number of phones a cell has registered",
       y = "Cell count",
       x = "Number of phones"))
ggsave("Network kind/Less dense/Plots/histogram.c.vec.png", c.vec.hist, device = "png")
```

## True P matrix

```{r}
P.long.complete.df <- full_join(signal.strength.llh.combined, C.vec.df, by = "cell") %>% 
  # dplyr::select(tile.id, pop, elevation, cell, type, dist, pij, phones.sum) %>% 
  dplyr::select(tile.id, pop, cell, type, dist, pij, phones.sum) %>% 
  mutate(tile.id.chr = tile.id) %>% 
  mutate(tile.id = factor(tile.id)) %>% 
  mutate(tile.id.num = as.numeric(tile.id)) %>% 
  mutate(cell.num = as.numeric(cell)) %>% 
  mutate(cell.chr = as.character(cell))

P.long.df <- P.long.complete.df %>% 
  dplyr::select(tile.id, tile.id.num, tile.id.chr, cell, cell.num, cell.chr, pij) %>% 
  distinct()


P.mat <- sparseMatrix(i = P.long.df$cell.num, 
                      j = P.long.df$tile.id.num, 
                      x = P.long.df$pij)


########### Super tiles with oracle
P.star.supertile.helper <- P.long.df %>% 
  dplyr::select(tile.id.chr, cell.chr, pij) %>% 
  filter(!pij == 0) %>%
  group_by(tile.id.chr) %>% 
  arrange(cell.chr) %>% 
  mutate(cell.comp = paste0(cell.chr, collapse = ""),
         pij.comp = paste0(pij, collapse = "")) %>% 
  ungroup() %>% 
  group_by(cell.comp, pij.comp) %>% 
  mutate(supertile.id = cur_group_id()) %>% 
  ungroup() %>% 
  mutate(supertile.id = factor(supertile.id)) %>% 
  mutate(supertile.id.num = as.numeric(supertile.id)) %>% 
  mutate(supertile.id.chr = as.character(supertile.id)) %>% 
  right_join(P.long.df, by = c("tile.id.chr", "cell.chr")) %>% 
  dplyr::select(tile.id, tile.id.num, tile.id.chr, supertile.id, supertile.id.num, supertile.id.chr, 
                cell, cell.num, cell.chr, pij = pij.x) %>% 
  filter(!is.na(pij)) # check this

P.star.supertile.joiner <- P.star.supertile.helper %>%  
  distinct(tile.id.num, supertile.id, supertile.id.num, supertile.id.chr) %>% 
  arrange(tile.id.num) 

  
P.star.supertile.helper %>%  
  distinct(tile.id, tile.id.num, tile.id.chr, supertile.id, supertile.id.num, supertile.id.chr, .keep_all = T) %>% 
  group_by(supertile.id.num) %>% 
  summarise(n = n()) %>% 
  ungroup() %>% 
  group_by(n) %>% 
  summarise(count = n()) %>% 
  datatable(caption = "Distribution of supertiles", rownames = F)


P.star.supertile.long.df <- P.star.supertile.helper %>%
  distinct(supertile.id, supertile.id.num, supertile.id.chr, cell, cell.num, cell.chr, pij) %>% 
  arrange(cell.num)



# append supertile id (oracle and equal) to sim area base objects
area$area.sf.complete <- area$area.sf %>% 
  left_join(P.star.supertile.joiner, by = c("tile.id" = "tile.id.num"))
area$area.df.complete <- area$area.df %>% 
  left_join(P.star.supertile.joiner, by = c("tile.id" = "tile.id.num"))

```


## Estimation

### Modelling P via P* and other necessary estimation objects (c.vec and prior)

```{r}

#### P* oracle
P.star.oracle.dt.d <- P.long.df %>% 
  dplyr::select(i = cell.num, j = tile.id.num, pij) %>% 
  as.data.table()

P.star.oracle.supertile.spm <- sparseMatrix(i = P.star.supertile.long.df$cell.num, 
                                            j = P.star.supertile.long.df$supertile.id.num, 
                                            x = P.star.supertile.long.df$pij)

P.star.oracle.supertile.dt <- data.table(i = P.star.supertile.long.df$cell.num,
                                         j = P.star.supertile.long.df$supertile.id.num,
                                         pij = P.star.supertile.long.df$pij)

### C vector, adding antennas that have 0 phones to complete the vector, arranging it according to the antenna.ID and saving as vector
c.vec <- P.long.complete.df %>% 
  distinct(cell, cell.num, cell.chr, phones.sum) %>% 
  right_join(cellplan.combined, by = "cell") %>% 
  mutate(phones.sum = case_when(is.na(phones.sum) ~ 0,
                                TRUE ~ phones.sum)) %>% 
  arrange(cell.num)

c.vec.dt <- data.table(i = c.vec$cell.num,
                       c = c.vec$phones.sum)


### prior vectors
a.tile.helper <- P.long.complete.df %>% 
  mutate(a = 1) %>% 
  distinct(tile.id.num, a)
a.tile.dt <- data.table(j = a.tile.helper$tile.id.num, u = a.tile.helper$a)

a.supertile.helper <- P.star.supertile.joiner %>% 
  group_by(supertile.id.num) %>% 
  summarise(a = n()) %>% 
  ungroup() %>% 
  distinct(supertile.id.num, a) %>% 
  deframe()

```

### Voronoi estimation (Tower, Offset, Hotpoint, Barycenter)

```{r}
# Voronoi

# Voronoi estimation with tower locations as seeds
VOR.tower <- VOR_est(area = area, 
                     cellplan.combined = cellplan.combined, 
                     signal.strength.comb.dt = signal.strength.comb.dt, 
                     C.vec.df = C.vec.df, 
                     seed = "tower")
VOR.tower.est <- VOR.tower$seed.voronoi.final %>% 
  rename(u.VOR.tower = u.VOR)


# Voronoi estimation with cell locations + offset as seeds
VOR.offset <- VOR_est(area = area, 
                     cellplan.combined = cellplan.combined, 
                     signal.strength.comb.dt = signal.strength.comb.dt, 
                     C.vec.df = C.vec.df, 
                     seed = "cell.offset",
                     offset = 10) 
VOR.offset.est <- VOR.offset$seed.voronoi.final %>% 
  rename(u.VOR.offset = u.VOR)


# Voronoi estimation with cell hotpoint locations as seeds
VOR.hotpoint <- VOR_est(area = area, 
                        cellplan.combined = cellplan.combined, 
                        signal.strength.comb.dt = signal.strength.comb.dt, 
                        C.vec.df = C.vec.df, 
                        seed = "cell.hotpoint") 
VOR.hotpoint.est <- VOR.hotpoint$seed.voronoi.final %>% 
  rename(u.VOR.hotpoint = u.VOR)

# Voronoi estimation with cell barycenter locations as seeds
VOR.barycenter <- VOR_est(area = area, 
                        cellplan.combined = cellplan.combined, 
                        signal.strength.comb.dt = signal.strength.comb.dt, 
                        C.vec.df = C.vec.df, 
                        seed = "cell.barycenter") 
VOR.barycenter.est <- VOR.barycenter$seed.voronoi.final %>% 
  rename(u.VOR.barycenter = u.VOR)

VOR.tower$Voronoi.regions.plot
ggsave("Network kind/Less dense/Plots/VOR_regions_tower.png", VOR.tower$Voronoi.regions.plot, device = "png")
VOR.offset$Voronoi.regions.plot
ggsave("Network kind/Less dense/Plots/VOR_regions_offset.png", VOR.offset$Voronoi.regions.plot, device = "png")
VOR.hotpoint$Voronoi.regions.plot
ggsave("Network kind/Less dense/Plots/VOR_regions_hotpoint.png", VOR.hotpoint$Voronoi.regions.plot, device = "png")
VOR.barycenter$Voronoi.regions.plot
ggsave("Network kind/Less dense/Plots/VOR_regions_barycenter.png", VOR.barycenter$Voronoi.regions.plot, device = "png")


```

### SB estimator
```{r}
SB.oracle.est <- EM_est(c.vec.dt = c.vec.dt, 
                        P.dt = P.star.oracle.dt.d, 
                        a.vec.dt = a.tile.dt, 
                        selected.range = 1,
                        n.iter = 1) %>% 
  dplyr::rename(tile.id = j, prior.SB.oracle = i.u, u.SB.oracle = u1)
```

### EM estimator

```{r}
EM.oracle.est <- EM_est(c.vec.dt = c.vec.dt, 
                        P.dt = P.star.oracle.dt.d, 
                        a.vec.dt = a.tile.dt, 
                        selected.range = c(1:10, seq(20, 90, 10), seq(100, 200, 50)),
                        n.iter = 200) %>% 
  rename_with(.fn = ~gsub("u", "u.EM.oracle", x = .x, fixed = T), 
              .cols = starts_with("u")) %>% 
  rename(tile.id = j, prior.EM.oracle = i.u)
```


### DF estimator

```{r}
## DF oracle

DF.oracle.est <- DF_est(c.vec.dt = c.vec.dt, 
                        P.star.spm = P.star.oracle.supertile.spm, 
                        a.supertile.vec = a.supertile.helper)
DF.oracle.est.dt <- data.table(j = as.numeric(names(a.supertile.helper)),
                               u = DF.oracle.est) %>%
  .[, u := fifelse(u < 1, 1, u)] # set negative values immediately to 0

## Renormalizing with EM and bringing estimate on tile.id level
DF_EM.oracle.est <- EM_est(c.vec.dt = c.vec.dt, 
                           P.dt = P.star.oracle.supertile.dt, a.vec.dt = DF.oracle.est.dt,
                           selected.range = c(1:10, seq(20, 90, 10), seq(100, 200, 50)),
                           n.iter = 200) %>% 
  rename_with(.fn = ~gsub("u", "u.DF_EM.oracle", x = .x, fixed = T), 
              .cols = starts_with("u")) %>% 
  rename(supertile.id.num = j, prior.DF_EM.oracle = i.u) %>%
  right_join(area$area.df.complete, by = "supertile.id.num") %>% 
  group_by(supertile.id) %>% 
  mutate(across(starts_with("u"), ~ . / n())) %>% 
  ungroup() %>% 
  dplyr::select(tile.id, starts_with("u"))

```



## Evaluation

### Putting all estimates together
```{r}
final.estimates.sf <- area$area.sf %>% 
  left_join(VOR.tower.est, by = "tile.id") %>% 
  left_join(VOR.offset.est, by = "tile.id") %>% 
  left_join(VOR.hotpoint.est, by = "tile.id") %>% 
  left_join(VOR.barycenter.est, by = "tile.id") %>% 
  left_join(SB.oracle.est, by = "tile.id") %>%
  left_join(EM.oracle.est, by = "tile.id") %>% 
  left_join(DF_EM.oracle.est, by = "tile.id")
  
final.estimates.df <- final.estimates.sf %>% 
  st_drop_geometry()

names.estimates <- final.estimates.sf %>% 
  # dplyr::select(pop, starts_with("u.")) %>% # all estimates
  dplyr::select(pop, matches("VOR|u.SB|oracle200")) %>% # only specific ones for mapping
  st_drop_geometry() %>% 
  names() 

```

### 1d Density evaluation

```{r}

# calculate density dataset for all estimates and GTP 
cdf.compare <- final.estimates.df %>% 
  dplyr::select(tile.id, all_of(names.estimates)) %>% 
  pivot_longer(cols = -tile.id, names_to = "estimates", values_to = "values") %>% 
  split(.$estimates) %>% 
  map(~custom_ecdf_prep(.)) %>% 
  map(~dplyr::select(., cum.prob.comp, pop.plot)) %>%
  map(~mutate(., cum.prob.comp = round(cum.prob.comp, 3))) %>% # effective plot sample --> faster plotting excluding overplot
  map_dfr(~distinct(.), .id = "type")
  

# ECCDF plot
(ECCDF.pop.plot <- cdf.compare %>% 
    ggplot() + 
    geom_line(aes(x = pop.plot, y = cum.prob.comp,
                  color = type), size = 1) + 
    scale_color_ptol() +
    scale_y_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
    scale_x_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
    annotation_logticks(sides = "lb") +
    labs(title = "ECCDF of estimators and GTP", y = "log10(ECCDF)", x = "log10(Mobile phones)",  
         colour = "") +
    theme(legend.position = "bottom"))
  
ggsave("Network kind/Less dense/Plots/eccdf.estimates.png", ECCDF.pop.plot, device = "png")

# ECDF.pop.plot <- ECDF.df %>%   
  #   ggplot() + 
  #   geom_point(aes(x = pop.plot, y = cum.prob.comp,
  #                  color = type
  #                  )) + 
  #   scale_color_ptol() +
  #   xlim(0, 30) +
  #   labs(title = "", y = "", x = "") +
  #   theme(legend.position = "none",
  #         plot.margin = unit(c(-0.5, 0, 0, -0.5), "cm")) 
  
  
  # combined <- ECCDF.pop.plot +
  #   annotation_custom(ggplotGrob(ECDF.pop.plot), 
  #                     xmin = 0, xmax = 1.5, 
  #                     ymin = min(ECCDF.df$log10.cum.prob.comp, na.rm = T), ymax = -1.5)
```


### 2d density evaluation

```{r}

names.order.estimator <- c("u.flat", 
                           "u.VOR.tower", "u.VOR.offset", "u.VOR.hotpoint", "u.VOR.barycenter",
                           "u.SB.oracle",
                           "u.EM.oracle", 
                           "u.DF_EM.oracle")

# define additional necessary rescalings of the area (next to 1x1)
rescale.factor.list <- list(area.1x1 = 1,
                            area.2x2 = 2, 
                            area.4x4 = 4, 
                            area.8x8 = 8)

# aggregate estimate values based on rescaling level
area.rescaled.grid <- map(rescale.factor.list, 
            ~st_make_grid(area$area.sf, cellsize = area$area.params[["base.tile.size"]] * .x))


mse.relevant.estimators <- final.estimates.sf %>% 
  dplyr::select(tile.id, pop, matches("VOR|SB|flat|1|10|100|200")) %>% 
  dplyr::select(-matches("prior"))
  

mse.est <- map(area.rescaled.grid, ~aggregate(mse.relevant.estimators, by = .x, FUN = mean, join = st_contains)) %>% 
  map(~st_drop_geometry(.))

point <- mse.est %>% 
  map(~mutate(., tile.id.rescaled = row_number())) %>% 
  map(~dplyr::select(., tile.id.rescaled, pop, starts_with("u."))) %>% 
  map_dfr(~pivot_longer(., cols = -c(tile.id.rescaled, pop), 
                        names_to = "estimator", values_to = "estimate"), .id = "scale") %>% 
  mutate(rescale.factor = as.numeric(str_extract(scale, "[[:digit:]]")),
         iteration = str_extract(estimator, "[[:digit:]]+"),
         kind = str_extract(estimator, "[[:alpha:][:punct:]]+")) %>% 
  mutate(iteration = case_when(is.na(iteration) ~ 0,
                               TRUE ~ as.numeric(iteration))) %>% 
  mutate(estimator.ordered = factor(kind, levels = names.order.estimator))


# selected estimators (iterations) for 2d density plots
scatter.names <- c("u.EM.oracle1", "u.EM.oracle10", "u.EM.oracle100", "u.EM.oracle200",
                   "u.VOR.barycenter", "u.VOR.tower")

(scatter.density.plots <- scatter.names %>% 
  map(~scatter_density(point, estimator.name = .x)) %>%
  set_names(scatter.names))

ggsave("Network kind/Less dense/Plots/u.EM.oracle1.2d.density.png", scatter.density.plots$u.EM.oracle1, device = "png")
ggsave("Network kind/Less dense/Plots/u.EM.oracle10.2d.density.png", scatter.density.plots$u.EM.oracle10, device = "png")
ggsave("Network kind/Less dense/Plots/u.EM.oracle100.2d.density.png", scatter.density.plots$u.EM.oracle100, device = "png")
ggsave("Network kind/Less dense/Plots/u.EM.oracle200.2d.density.png", scatter.density.plots$u.EM.oracle200, device = "png")
ggsave("Network kind/Less dense/Plots/u.VOR.barycenter.2d.density.png", scatter.density.plots$u.VOR.barycenter, device = "png")
ggsave("Network kind/Less dense/Plots/u.VOR.tower.2d.density.png", scatter.density.plots$u.VOR.tower, device = "png")



```


### Spatial density evaluation

```{r}

maps.labels <- list("GTP  ", "VOR_t", "VOR_o", "VOR_h", "VOR_b", "SB_o ", "EM_o ", "DF_o ")

# check if there is divergence, what are the maximum estimates per tile for each estimator
max.maps <- final.estimates.sf %>% 
  st_drop_geometry() %>% 
  dplyr::select(tile.id, pop, matches("VOR|u.SB|oracle200")) %>% # only specific ones for mapping
  summarise_all(max) %>% 
  pivot_longer(cols = -tile.id, names_to = "estimator", values_to = "estimate")


# Define break points for discretized spatial density plots
breaks <- c(0, 2, 10, 20, 50, 100, 200, 500, 1000, Inf)
maps.input <- final.estimates.sf %>% 
  dplyr::select(tile.id, pop, all_of(names.estimates)) %>% 
  mutate(across(c(pop, starts_with("u.")), ~cut(., breaks = breaks, dig.lab = 7, right = F)))

# Build plots
(maps.estimation.density <- names.estimates %>%
  map2(., maps.labels, ~map_density(data = maps.input, var = .x, label = .y)) %>%
  set_names(names.estimates))

ggsave("Network kind/Less dense/Plots/pop.map.png", maps.estimation.density$pop, device = "png")
ggsave("Network kind/Less dense/Plots/u.VOR.tower.map.png", maps.estimation.density$u.VOR.tower, device = "png")
ggsave("Network kind/Less dense/Plots/u.VOR.offset.map.png", maps.estimation.density$u.VOR.offset, device = "png")
ggsave("Network kind/Less dense/Plots/u.VOR.hotpoint.map.png", maps.estimation.density$u.VOR.hotpoint, device = "png")
ggsave("Network kind/Less dense/Plots/u.VOR.barycenter.map.png", maps.estimation.density$u.VOR.barycenter, device = "png")
ggsave("Network kind/Less dense/Plots/u.SB.oracle.map.png", maps.estimation.density$u.SB.oracle, device = "png")
ggsave("Network kind/Less dense/Plots/u.EM.oracle200.map.png", maps.estimation.density$u.EM.oracle200, device = "png")
ggsave("Network kind/Less dense/Plots/u.DF_EM.oracle200.map.png", maps.estimation.density$u.DF_EM.oracle200, device = "png")

```





### KWD evaluation 


#### Preparing KWD for all estimates

```{r}
kwd.helper.est <- final.estimates.sf %>% 
  dplyr::select(-c(elevation, type)) %>%
  mutate(u.flat = mean(pop)) %>% 
  mutate(lon = map_dbl(geometry, ~st_centroid(.x)[[1]]),
         lat = map_dbl(geometry, ~st_centroid(.x)[[2]])) %>% 
  st_drop_geometry()

coordinates <- kwd.helper.est %>% 
  dplyr::select(lon, lat) %>% 
  as.matrix()

weights <- kwd.helper.est %>% 
  dplyr::select(pop, matches("u.")) %>% 
  as.matrix()

kwd.final <- compareOneToMany(coordinates, weights, L = 3, recode = TRUE)
cat("runtime:", kwd.final$runtime, " distance:", kwd.final$distance, " nodes:", 
    kwd.final$nodes, "arcs:", kwd.final$arcs, "\n")

names.weights <- colnames(weights)[-1]

kwd.eval <- tibble(estimator = names.weights,
                   kwd = kwd.final$distance * 1) %>%  # rescaling according to scale
  mutate(kwd.lower.bound = kwd - ((kwd / 100) * 1.29)) %>%  # for L=3 within 1 percent 
  mutate(iteration = str_extract(estimator, "[[:digit:]]+"),
         kind = str_extract(estimator, "[[:alpha:][:punct:]]+")) %>%
  mutate(iteration = case_when(is.na(iteration) ~ 0,
                               TRUE ~ as.numeric(iteration))) %>% 
  mutate(time.var = as.numeric(iteration) * 1,
         time.fix = case_when(str_detect(kind, "DF") ~ 3,
                              str_detect(kind, "u.EM") ~ 0)) %>%  # 11 min MP inverse
  mutate(time.final = (time.var + time.fix)) %>%
  group_by(kind) %>% 
  mutate(min.kwd.kind = min(kwd),
         kind.group = row_number() / max(row_number())) %>% # find minimum per estimator (for ordering help)
  ungroup() %>% 
  arrange(desc(min.kwd.kind), iteration) %>% 
  mutate(final.order = row_number()) %>% 
  mutate(estimator.new = factor(final.order, labels = estimator))
```

#### KWD final estimates

```{r}
flat.ref <- round(as.numeric(kwd.eval[kwd.eval$estimator == "u.flat", "kwd"]), 2)

(kwd.final.estimates.plot <- kwd.eval %>% 
    filter(kind.group == 1,
           !str_detect(estimator, "flat|prior")) %>% 
    ggplot(aes(x = estimator.new, y = kwd, fill = kind, alpha = kind.group)) + 
    geom_bar(stat = "identity", position = position_dodge(width = 0.9)) + 
    geom_errorbar(aes(ymin = kwd.lower.bound, ymax = kwd), position = position_dodge(width = 0.9), width = 0.25) +
    geom_text(aes(x = estimator.new, y = kwd, label = round(kwd, 2)), 
              position = position_dodge(0.1), hjust = -0.1, color = "Black", size = 3) +
    scale_alpha(range = c(0.5, 1), 
                guide = F
                # labels = unique(kwd.eval$iteration)
                ) + # noch Ã¤ndern
    scale_fill_ptol(guide = FALSE) +
    coord_flip() +
    labs(x = "", y = "KWD", 
         alpha = "Iteration", 
         subtitle = paste0("(Reference: Flat = ", flat.ref, ")")) + 
    theme(legend.position = "bottom"))

ggsave(filename = "Network kind/Less dense/Plots/kwd.final.estimates.plot.png", plot = kwd.final.estimates.plot, device = "png")
```


#### KWD convergence (EM and DF)

```{r}

kwd.eval.convergence <- kwd.eval %>% 
  filter(!iteration == 0)

(kwd.convergence.plot.log.text <- kwd.eval.convergence %>% 
    dplyr::select(estimator, kwd, kwd.lower.bound, iteration, kind) %>% 
    ggplot(aes(x = iteration, y = kwd)) +
    geom_line(aes(color = kind)) +
    geom_point(aes(color = kind)) +
    geom_ribbon(aes(ymin = kwd.lower.bound, ymax = kwd, group = kind), alpha = 0.2) +
    geom_text_repel(aes(color = kind, label = round(kwd, 2)), size = 3, show.legend  = F) +
    scale_x_log10(labels = scales::trans_format("log10", scales::math_format(10^.x))) +
    annotation_logticks(sides = "b") +
    labs(color = "Estimator",
         x = "Iteration",
         y = "KWD"))


ggsave("Network kind/Less dense/Plots/kwd.convergence.png", kwd.convergence.plot.log.text, device = "png")


(time.convergence.plot <- kwd.eval.convergence %>% 
    dplyr::select(estimator, time.final, iteration, kind) %>% 
    ggplot() +
    geom_line(aes(x = iteration, y = time.final, color = kind)) +
    geom_point(aes(x = iteration, y = time.final, color = kind)) +
    scale_color_discrete(breaks = c("u.DF_EM.oracle", "u.EM.oracle"), labels = c("DF_o", "EM_o")) +
    labs(color = "Estimator",
         x = "Iteration",
         y = "Time in seconds"))
  
ggsave("Network kind/Less dense/Plots/computation.time.png", time.convergence.plot, device = "png")

```






